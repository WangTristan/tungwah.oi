# 🏗️ 数据结构 (Data Structures)

**数据结构**是组织、存储和管理数据的方式。选择合适的数据结构，能够让算法在时间和空间上达到最优效率。在 OI 竞赛中，数据结构与算法是密不可分的。

学习数据结构的关键在于理解其**存储方式**、**核心操作**（插入、删除、查询）及其对应的**时间复杂度**。

## 一、线性数据结构：基础与进阶

线性结构是指数据元素之间存在一对一关系，像一条直线一样排列的数据组织方式。

### 1. 栈 (Stack) 与 队列 (Queue)

它们都是对数组或链表进行封装，限制了数据的存取方式，从而实现特定的功能：

* **栈 (Stack)**：遵循 **LIFO**（Last In, First Out，后进先出）原则。常用于表达式求值、递归实现和回溯。
* **队列 (Queue)**：遵循 **FIFO**（First In, First Out，先进先出）原则。常用于广度优先搜索 (BFS) 和任务调度。

### 2. 链表 (Linked List)

链表通过**指针**将数据元素连接起来，其优势在于**高效的插入和删除操作**（$O(1)$），但随机访问元素效率低（$O(N)$）。

## 二、树形数据结构：层次化管理

树形结构是 OI 竞赛中最重要的结构类型之一，用于处理具有**层次关系**的数据或需要高效查询与修改的问题。

### 1. 树 (Tree) 和 二叉树 (Binary Tree)

树是基础的层次结构，而二叉树是每节点最多有两个子节点的树。许多高级数据结构都是基于二叉树变种而来的。

### 2. 堆 (Heap)

堆是一种特殊的二叉树，满足堆性质：父节点的值总是大于（或小于）其子节点的值。堆能够快速获取集合中的**最大值或最小值**（$O(1)$），插入和删除操作复杂度为 $O(\log N)$。常用于优先队列、堆排序和 Dijkstra 算法优化。


### 3. 并查集 (Disjoint Set Union, DSU)

并查集用于管理元素的分组，能够高效地完成两个操作：

* **查找 (Find)**：确定元素属于哪个集合（即根节点）。
* **合并 (Union)**：将两个集合合并为一个。

通过路径压缩和按秩合并等优化，并查集的平均操作时间复杂度接近 $O(1)$。常用于解决连通性问题，如 Kruskal 算法求最小生成树。

## 三、高级数据结构：复杂查询与维护

### 1. 线段树 (Segment Tree)

线段树用于维护**区间信息**，可以在 $O(\log N)$ 的时间复杂度内完成对数组任意区间（如求和、求最值）的**修改和查询**操作。它是处理区间问题的利器。


### 2. 平衡树 (Balanced Search Tree)

平衡树（如 AVL 树、红黑树、Splay 树）是二叉搜索树的变种。它们通过动态调整结构来保证树的高度始终保持在 $O(\log N)$ 级别，从而确保所有操作（插入、删除、查询第 k 小、前驱后继）都能在**对数时间**内完成。
