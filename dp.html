<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态规划 (DP) - 东华初级中学 OI Wiki</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <header>
        <div class="container">
            <h1>东华初级中学 OI Wiki</h1>
            <nav>
                <ul>
                    <li><a href="index.html">首页</a></li>
                    <li><a href="basic.html">基础算法</a></li>
                    <li><a href="data_structure.html">数据结构</a></li>
                    <li><a href="dp.html">动态规划</a></li>
                    <li><a href="graph.html">图论</a></li>
                    <li><a href="exam_guide.html">考试指南</a></li>
                    <li><a href="history.html">日志</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <div class="container">
            <section id="dp-introduction">
                <h2>动态规划 (Dynamic Programming, DP)</h2>
                <p>动态规划是一种在数学、计算机科学和经济学中使用的，通过把<strong>复杂问题分解成更简单的子问题</strong>来解决优化问题的技术。</p>
                <p>它与分治法类似，但关键区别在于：<strong>子问题之间存在重叠</strong>。DP 通过储存并复用这些重叠子问题的解，避免了重复计算，从而大大提高了效率。</p>
                
                <h3>DP 的两大特征</h3>
                <ol>
                    <li><strong>最优子结构 (Optimal Substructure)</strong>: 问题的最优解包含着其子问题的最优解。</li>
                    <li><strong>重叠子问题 (Overlapping Subproblems)</strong>: 在求解过程中，许多子问题会被重复求解。</li>
                </ol>
            </section>
            
            <section id="lis">
                <h2>经典问题一：最长递增子序列 (LIS)</h2>
                <p>给定一个数列 $A = (a_1, a_2, \dots, a_n)$，求出它的一个子序列，使得这个子序列元素是<strong>严格递增</strong>的，并且长度<strong>最长</strong>。</p>
                
                <h3>定义状态</h3>
                <p>我们定义 $DP[i]$ 表示：以 $a_i$ 这个元素<strong>结尾</strong>的最长递增子序列的长度。</p>
                
                <h3>状态转移方程</h3>
                <p>要计算 $DP[i]$L，我们需要向前看，遍历所有 $j < i$。如果 $a_j < a_i$，则说明 $a_i$ 可以接在以 $a_j$ 结尾的递增子序列后面。因此：</p>
                $$DP[i] = \max(\{DP[j] + 1 \mid j < i, a_j < a_i\} \cup \{1\})$$
                <p>最终答案是所有 $DP[i]$ 中的最大值。</p>
                
                <h3>代码示例 (C++)</h3>
                <pre><code>
int LIS(const std::vector<int>& a) {
    int n = a.size();
    if (n == 0) return 0;
    
    std::vector<int> dp(n, 1); // 初始化，每个元素本身都是长度为1的递增子序列
    int max_len = 1;
    
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            // 如果 a[i] 可以接在以 a[j] 结尾的子序列后面
            if (a[j] < a[i]) {
                dp[i] = std::max(dp[i], dp[j] + 1);
            }
        }
        max_len = std::max(max_len, dp[i]);
    }
    return max_len;
}
                </code></pre>
            </section>

            <section id="knapsack">
                <h2>💰 经典问题二：0/1 背包问题</h2>
                <p>有 $N$ 个物品，第 $i$ 个物品的重量为 $w_i$，价值为 $v_i$。给定一个容量为 $W$ 的背包，问如何选择物品装入背包，使得装入背包的物品<strong>总重量不超过 $W$</strong> 的前提下，<strong>总价值最大</strong>。</p>
                
                <h3>定义状态</h3>
                <p>我们定义 $DP[i][j]$ 表示：<strong>只考虑前 $i$ 个物品</strong>，背包容量为 $j$ 时，能获得的最大价值。</p>
                
                
                <h3>状态转移方程</h3>
                <p>对于第 $i$ 个物品，我们只有两种选择：</p>
                <ul>
                    <li><strong>不选第 $i$ 个物品</strong>: 此时的最大价值等于只考虑前 $i-1$ 个物品、容量仍为 $j$ 时的最大价值，即 $DP[i-1][j]$。</li>
                    <li><strong>选第 $i$ 个物品 (前提是 $w_i \le j$)</strong>: 此时的最大价值等于 $v_i$ 加上只考虑前 $i-1$ 个物品、容量为 $j-w_i$ 时的最大价值，即 $DP[i-1][j-w_i] + v_i$。</li>
                </ul>
                $$\text{当 } w_i > j \text{ 时：} DP[i][j] = DP[i-1][j]$$
                $$\text{当 } w_i \le j \text{ 时：} DP[i][j] = \max(DP[i-1][j], DP[i-1][j-w_i] + v_i)$$
                <p>最终答案是 $DP[N][W]$。</p>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 东华初级中学 OI. 保留所有权利。</p>
        </div>
    </footer>

</body>
</html>
